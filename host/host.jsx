/**
 * ListMatic V2 - Host Script (ExtendScript)
 * FOR SYSTEMATIC WORK
 */

#target photoshop

var PROGRESS = { current: 0, total: 0, status: "Ready", done: false };
var CANCELLED = false;
var PAUSED = false;
var SKIP_CURRENT = false;
var prefsFile = new File(Folder.userData + "/miami_panel_prefs.json");

function cancelProcessing() {
    CANCELLED = true;
    PROGRESS.status = "Cancelled";
    PROGRESS.done = true;
}

// Check if user pressed ESC key or cancelled
function checkForUserCancel() {
    // Allow Photoshop to process events (including ESC key)
    try {
        app.refresh();
        $.sleep(10); // Small delay to allow event processing
    } catch (e) { }

    // Check ScriptUI for ESC key state
    try {
        if (ScriptUI.environment && ScriptUI.environment.keyboardState) {
            var keyName = ScriptUI.environment.keyboardState.keyName;
            if (keyName === "Escape") {
                CANCELLED = true;
                PROGRESS.status = "Cancelled by user (ESC)";
                PROGRESS.done = true;
                return true;
            }
        }
    } catch (e) { }

    return CANCELLED;
}

function loadPreferencesJSON() {
    if (!prefsFile.exists) return "null";
    try { prefsFile.open("r"); var c = prefsFile.read(); prefsFile.close(); return c; }
    catch (e) { return "null"; }
}

function savePreferencesJSON(jsonStr) {
    try { prefsFile.open("w"); prefsFile.write(jsonStr); prefsFile.close(); return "ok"; }
    catch (e) { return "error"; }
}

function selectFileDialog(filter) {
    var f = File.openDialog("Select File", filter);
    return f ? f.fsName : "null";
}

function selectFolderDialog() {
    var f = Folder.selectDialog("Select Folder");
    return f ? f.fsName : "null";
}

function showColorPickerDialog() {
    if (app.showColorPicker()) return app.foregroundColor.rgb.hexValue;
    return "null";
}

function getForegroundColor() {
    try { return app.foregroundColor.rgb.hexValue; }
    catch (e) { return "FF0000"; }
}

function openFolder(path) {
    var f = new Folder(path);
    if (f.exists) f.execute();
}

function openInBrowser(path) {
    var f = new File(path);
    if (f.exists) f.execute();
}

// ==================== METADATA INJECTION ====================
function injectMetadata(doc, metaConfig, productData) {
    if (!metaConfig || !metaConfig.enabled) return;

    try {
        // Build title from template - support ANY column name as placeholder
        var title = metaConfig.titleTemplate || '{Brand} {Model}';

        // Replace all placeholders with actual values from productData
        // Find all {something} patterns and replace with corresponding values
        for (var key in productData) {
            if (productData.hasOwnProperty(key)) {
                var placeholder1 = '{' + key + '}';  // lowercase
                var placeholder2 = '{' + key.charAt(0).toUpperCase() + key.slice(1) + '}';  // Capitalized
                var placeholder3 = '{' + key.toUpperCase() + '}';  // UPPERCASE

                var value = productData[key] || '';
                title = title.split(placeholder1).join(value);
                title = title.split(placeholder2).join(value);
                title = title.split(placeholder3).join(value);
            }
        }
        title = safeTrim(title);

        // Get description from product data
        var description = '';
        if (metaConfig.descriptionCol && productData[metaConfig.descriptionCol.toLowerCase()]) {
            description = productData[metaConfig.descriptionCol.toLowerCase()];
        }

        // Get keywords from product data
        var keywords = [];
        if (metaConfig.keywordsCol && productData[metaConfig.keywordsCol.toLowerCase()]) {
            var keywordStr = productData[metaConfig.keywordsCol.toLowerCase()];
            // Split by comma, semicolon, or pipe
            var keyArr = keywordStr.split(/[,;|]/);
            for (var k = 0; k < keyArr.length; k++) {
                var kw = safeTrim(keyArr[k]);
                if (kw) keywords.push(kw);
            }
        }

        // Add brand and model as keywords automatically
        if (productData.brand) keywords.push(productData.brand);
        if (productData.model) keywords.push(productData.model);

        // Apply metadata to document
        if (title) doc.info.title = title;
        if (description) doc.info.description = description;
        if (keywords.length > 0) doc.info.keywords = keywords;

        // Author - user defined, Copyright - fixed as ListMatic V3
        var authorName = metaConfig.author || '';
        doc.info.copyrightNotice = '© ListMatic V3';  // Fixed - always ListMatic
        doc.info.credit = 'Generated by ListMatic V3';  // Fixed
        if (authorName) {
            doc.info.author = authorName;  // User's name
        }

    } catch (e) {
        // Metadata injection failed silently
    }
}

function getDocumentColors() { return "[]"; }
function readCSVPreview(path) { return "[]"; }
function exportCurrentDocument() { return "null"; }
function getProgress() { return JSON.stringify(PROGRESS); }
function cancelProcessing() { CANCELLED = true; }

// Count CSV rows (excluding header)
function countCSVRows(path) {
    try {
        var f = new File(path);
        if (!f.exists) return "0";
        f.encoding = "UTF8";
        if (!f.open("r")) return "0";
        var count = 0;
        var firstLine = true;
        while (!f.eof) {
            var line = f.readln();
            if (firstLine) {
                firstLine = false;
                continue; // Skip header
            }
            if (safeTrim(line)) count++;
        }
        f.close();
        return String(count);
    } catch (e) {
        return "0";
    }
}

function generatePSDPreview(psdPath) {
    try {
        var psdFile = new File(psdPath);
        if (!psdFile.exists) return JSON.stringify({ error: "File not found" });
        var doc = app.open(psdFile);
        var tempFolder = new Folder(Folder.temp.fsName + "/MiamiPanel");
        if (!tempFolder.exists) tempFolder.create();
        var maxSize = 300;
        var w = doc.width.as("px");
        var h = doc.height.as("px");
        var scale = Math.min(maxSize / w, maxSize / h, 1);
        var dupDoc = doc.duplicate("Preview");
        dupDoc.flatten();
        dupDoc.resizeImage(new UnitValue(w * scale, "px"), new UnitValue(h * scale, "px"), 72, ResampleMethod.BICUBIC);
        var previewFile = new File(tempFolder.fsName + "/preview_" + new Date().getTime() + ".jpg");
        var jpgOpt = new JPEGSaveOptions();
        jpgOpt.quality = 8;
        dupDoc.saveAs(previewFile, jpgOpt, true);
        dupDoc.close(SaveOptions.DONOTSAVECHANGES);
        doc.close(SaveOptions.DONOTSAVECHANGES);
        return JSON.stringify({
            success: true,
            path: previewFile.fsName,
            width: Math.round(w * scale),
            height: Math.round(h * scale)
        });
    } catch (e) {
        try { app.activeDocument.close(SaveOptions.DONOTSAVECHANGES); } catch (x) { }
        return JSON.stringify({ error: e.message });
    }
}

function readTextFile(path) {
    var f = new File(path);
    if (!f.exists) return "null";
    f.encoding = "UTF8";
    if (f.open("r")) {
        var content = f.read();
        f.close();
        return content;
    }
    return "null";
}

function saveTextFile(path, content) {
    var f = new File(path);
    f.encoding = "UTF8";
    if (f.open("w")) {
        f.write(content);
        f.close();
        return "ok";
    }
    return "error";
}

function runBulkResize(configJSON) {
    try {
        var config = eval('(' + configJSON + ')');
        var inputFolder = new Folder(config.input);
        var outputFolder = new Folder(config.output);
        if (!inputFolder.exists) return JSON.stringify({ error: "Input folder not found" });
        if (!outputFolder.exists) outputFolder.create();
        var files = inputFolder.getFiles(/\.(jpg|jpeg|png|gif|bmp|tiff?)$/i);
        var count = 0;
        for (var i = 0; i < files.length; i++) {
            try {
                var doc = app.open(files[i]);
                var w = doc.width.as("px");
                var h = doc.height.as("px");
                var scaleW = config.maxWidth / w;
                var scaleH = config.maxHeight / h;
                var scale = Math.min(scaleW, scaleH, 1);
                if (scale < 1) {
                    doc.resizeImage(new UnitValue(w * scale, "px"), new UnitValue(h * scale, "px"), 72, ResampleMethod.BICUBIC);
                }
                var outFile = new File(outputFolder.fsName + "/" + files[i].name);
                var ext = files[i].name.split('.').pop().toLowerCase();
                if (ext === 'jpg' || ext === 'jpeg') {
                    var opt = new JPEGSaveOptions();
                    opt.quality = 10;
                    doc.saveAs(outFile, opt, true);
                } else if (ext === 'png') {
                    var opt = new PNGSaveOptions();
                    doc.saveAs(outFile, opt, true);
                }
                doc.close(SaveOptions.DONOTSAVECHANGES);
                count++;
            } catch (e) { }
        }
        return JSON.stringify({ count: count });
    } catch (e) {
        return JSON.stringify({ error: e.message });
    }
}

function safeTrim(v) { return (v == null ? "" : String(v).replace(/^\s+|\s+$/g, "")); }

function parseCSVLine(line) {
    var out = [], cur = "", q = false;
    for (var i = 0; i < line.length; i++) {
        var c = line.charAt(i);
        if (c == '"') q = !q;
        else if (c == ',' && !q) { out.push(cur); cur = ""; }
        else cur += c;
    }
    out.push(cur);
    return out;
}

function parseCSV(path) {
    var f = new File(path);
    f.encoding = "UTF8";
    if (!f.open("r")) return [];
    var lines = [];
    while (!f.eof) lines.push(f.readln());
    f.close();
    return lines;
}

function findLayerByName(doc, name) {
    var nameLower = safeTrim(name).toLowerCase();
    function scan(container) {
        for (var i = 0; i < container.layers.length; i++) {
            var lyr = container.layers[i];
            try {
                if (safeTrim(lyr.name).toLowerCase() === nameLower) return lyr;
                if (lyr.typename === "LayerSet") {
                    var hit = scan(lyr);
                    if (hit) return hit;
                }
            } catch (e) { }
        }
        return null;
    }
    return scan(doc);
}

function updateText(doc, layerName, text) {
    try {
        var lyr = findLayerByName(doc, layerName);
        if (lyr && lyr.kind === LayerKind.TEXT) lyr.textItem.contents = String(text || "");
    } catch (e) { }
}

function addCommas(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function splitPriceCurrency(raw) {
    var s = safeTrim(raw);
    if (!s) return { num: "", cur: "" };
    var m = s.match(/([\d,\.]+)\s*(EGP|USD|SAR)?$/i);
    if (m) return { num: addCommas(m[1].replace(/,/g, "")), cur: m[2] ? m[2].toUpperCase() : "EGP" };
    if (/^\d+$/.test(s)) return { num: addCommas(s), cur: "EGP" };
    return { num: s, cur: "" };
}

function parseHexToColor(hexText) {
    var t = safeTrim(hexText).replace(/[^0-9a-fA-F]/g, "");
    if (t.length === 3) t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2];
    if (t.length !== 6) return null;
    var c = new SolidColor();
    c.rgb.red = parseInt(t.substr(0, 2), 16);
    c.rgb.green = parseInt(t.substr(2, 2), 16);
    c.rgb.blue = parseInt(t.substr(4, 2), 16);
    return c;
}

function resolveImageFile(imagePath, csvDir, imagesFolder) {
    var raw = safeTrim(imagePath).replace(/\uFEFF/g, "");
    if (!raw) return null;
    var f = new File(raw);
    if (f.exists) return f;
    var parts = raw.replace(/\\/g, "/").split("/");
    var fileName = parts[parts.length - 1];
    var baseName = fileName.replace(/\.[^.]+$/, "");
    function tryFile(folder, name) {
        if (!folder) return null;
        var f1 = new File(folder.fsName + "/" + name);
        if (f1.exists) return f1;
        var exts = [".png", ".jpg", ".jpeg"];
        for (var i = 0; i < exts.length; i++) {
            var f2 = new File(folder.fsName + "/" + baseName + exts[i]);
            if (f2.exists) return f2;
        }
        return null;
    }
    if (imagesFolder) {
        var imgFolder = new Folder(imagesFolder);
        var f2 = tryFile(imgFolder, fileName);
        if (f2) return f2;
    }
    return tryFile(csvDir, fileName);
}

function placeImageNormalized(doc, imgFile, targetName) {
    try {
        var target = findLayerByName(doc, targetName);
        if (!imgFile || !imgFile.exists || !target) return;

        var oldRuler = app.preferences.rulerUnits;
        app.preferences.rulerUnits = Units.PIXELS;

        var docW = doc.width.as("px"), docH = doc.height.as("px");
        var b = target.bounds;
        var tX = (b[0].as("px") + b[2].as("px")) / 2 / docW;
        var tB = b[3].as("px") / docH;
        var tH = (b[3].as("px") - b[1].as("px")) / docH;

        app.activeDocument = doc;
        try {
            doc.activeLayer = target;
        } catch (e) { }

        var imgDoc = app.open(imgFile);
        imgDoc.selection.selectAll();
        imgDoc.selection.copy();
        imgDoc.close(SaveOptions.DONOTSAVECHANGES);

        doc.paste();
        var pasted = doc.activeLayer;
        pasted.name = targetName;

        var pb = pasted.bounds;
        var nH = (pb[3].as("px") - pb[1].as("px")) / docH;
        if (nH > 0) pasted.resize((tH / nH) * 100, (tH / nH) * 100, AnchorPosition.MIDDLECENTER);

        pb = pasted.bounds;
        var nX = (pb[0].as("px") + pb[2].as("px")) / 2 / docW;
        var nB = pb[3].as("px") / docH;
        pasted.translate(new UnitValue((tX - nX) * docW, "px"), new UnitValue((tB - nB) * docH, "px"));

        try { target.remove(); } catch (e) { }

        app.preferences.rulerUnits = oldRuler;
    } catch (e) { }
}

function addWatermark(doc) {
    try {
        var oldRuler = app.preferences.rulerUnits;
        app.preferences.rulerUnits = Units.PIXELS;
        var docW = doc.width.as("px");
        var docH = doc.height.as("px");
        var fontSize = Math.max(3, Math.min(6, docW * 0.005));
        var watermark = doc.artLayers.add();
        watermark.kind = LayerKind.TEXT;
        watermark.name = "Watermark";
        watermark.textItem.contents = "ListMatic";
        watermark.textItem.size = new UnitValue(fontSize, "pt");
        watermark.textItem.font = "ArialMT";
        var wColor = new SolidColor();
        wColor.rgb.red = 100;
        wColor.rgb.green = 100;
        wColor.rgb.blue = 100;
        watermark.textItem.color = wColor;
        var marginX = Math.max(3, docW * 0.005);
        var marginY = Math.max(3, docH * 0.005);
        watermark.textItem.position = [marginX, docH - marginY];
        watermark.opacity = 15;
        app.preferences.rulerUnits = oldRuler;
    } catch (e) { }
}

function saveAsWEBP(doc, filePath, quality) {
    try {
        var desc = new ActionDescriptor();
        var descExport = new ActionDescriptor();
        descExport.putEnumerated(stringIDToTypeID("format"), stringIDToTypeID("format"), stringIDToTypeID("WEBP"));
        descExport.putInteger(stringIDToTypeID("quality"), quality || 80);
        descExport.putBoolean(stringIDToTypeID("lossless"), false);
        desc.putObject(stringIDToTypeID("target"), stringIDToTypeID("exportTarget"), descExport);
        desc.putPath(stringIDToTypeID("in"), new File(filePath));
        executeAction(stringIDToTypeID("exportDocument"), desc, DialogModes.NO);
        return true;
    } catch (e) { return false; }
}

function runBatchProcess(configJSON) {
    try {
        var config = eval('(' + configJSON + ')');

        var csvFile = new File(config.csv);
        var saveFolder = new Folder(config.save);

        if (!csvFile.exists) return JSON.stringify({ error: "CSV file not found: " + config.csv });
        if (!saveFolder.exists) saveFolder.create();

        var fbPSD = config.fb ? new File(config.fb) : null;
        var igPSD = config.ig ? new File(config.ig) : null;
        var tplPSD = config.tpl ? new File(config.tpl) : null;

        var scalePct = config.scale || 100;
        var curColor = parseHexToColor(config.color);
        var jpgQuality = config.jpgQuality || 12;

        var mapBrand = config.mapBrand || "Brand";
        var mapModel = config.mapModel || "Model";
        var mapStorage = config.mapStorage || "Storage";
        var mapPrice = config.mapPrice || "Price";
        var mapImage = config.mapImage || "Image";

        // Build dynamic mapping lookup: csvColumn -> layerName
        var dynamicMappings = {};
        if (config.mappings && config.mappings.length > 0) {
            for (var m = 0; m < config.mappings.length; m++) {
                var mapping = config.mappings[m];
                if (mapping.csvColumn && mapping.layerName) {
                    dynamicMappings[mapping.csvColumn.toLowerCase()] = mapping.layerName;
                }
            }
        }

        // Helper function to get column index by name
        function getColumnIndex(headers, colName) {
            if (!colName) return -1;
            var lowerName = colName.toLowerCase();
            for (var c = 0; c < headers.length; c++) {
                if (safeTrim(headers[c]).toLowerCase() === lowerName) {
                    return c;
                }
            }
            return -1;
        }

        // Helper function to get layer name for a CSV column
        function getLayerForColumn(csvColName) {
            if (!csvColName) return null;
            var lowerName = csvColName.toLowerCase();
            if (dynamicMappings[lowerName]) {
                return dynamicMappings[lowerName];
            }
            // Default: same name
            return csvColName;
        }

        var lines = parseCSV(csvFile.fsName);
        if (lines.length < 2) return JSON.stringify({ error: "CSV is empty or has no data rows" });

        var psdCount = (fbPSD && fbPSD.exists ? 1 : 0) + (igPSD && igPSD.exists ? 1 : 0) + (tplPSD && tplPSD.exists ? 1 : 0);
        if (psdCount === 0) return JSON.stringify({ error: "No valid PSD files found" });

        PROGRESS.total = (lines.length - 1) * psdCount;
        PROGRESS.current = 0;
        PROGRESS.done = false;
        CANCELLED = false;

        var processed = 0;

        var csvBaseName = csvFile.name.replace(/\.[^.]+$/, "");
        var combinedFolder = new Folder(saveFolder.fsName + "/" + csvBaseName);
        if (!combinedFolder.exists) combinedFolder.create();

        function processPSD(psdFile, subFolderName) {
            if (!psdFile || !psdFile.exists) return;

            var outDir = new Folder(saveFolder.fsName + "/" + subFolderName);
            if (!outDir.exists) outDir.create();

            var combinedSubDir = new Folder(combinedFolder.fsName + "/" + subFolderName);
            if (!combinedSubDir.exists) combinedSubDir.create();

            var counter = 1;
            var headers = parseCSVLine(lines[0]); // Parse header row for metadata
            for (var i = 1; i < lines.length; i++) {
                if (checkForUserCancel()) break;

                try {
                    var cols = parseCSVLine(lines[i]);
                    while (cols.length < headers.length) cols.push("");

                    // Find column indices based on mappings
                    // Mappings format: { csvColumn: 'CSV Name', layerName: 'Layer Name' }
                    function findCsvColForLayer(layerType) {
                        if (!config.mappings) return layerType;
                        for (var mm = 0; mm < config.mappings.length; mm++) {
                            if (config.mappings[mm].layerName &&
                                config.mappings[mm].layerName.toLowerCase() === layerType.toLowerCase()) {
                                return config.mappings[mm].csvColumn;
                            }
                        }
                        return layerType;
                    }

                    var brandCol = findCsvColForLayer('Brand');
                    var modelCol = findCsvColForLayer('Model');
                    var storageCol = findCsvColForLayer('Storage');
                    var priceCol = findCsvColForLayer('Price');
                    var imageCol = findCsvColForLayer('Image');

                    var brandColIdx = getColumnIndex(headers, brandCol);
                    var modelColIdx = getColumnIndex(headers, modelCol);
                    var storageColIdx = getColumnIndex(headers, storageCol);
                    var priceColIdx = getColumnIndex(headers, priceCol);
                    var imageColIdx = getColumnIndex(headers, imageCol);

                    // Fallback to first columns if not found
                    if (brandColIdx === -1) brandColIdx = 0;
                    if (modelColIdx === -1) modelColIdx = 1;
                    if (storageColIdx === -1) storageColIdx = 2;
                    if (priceColIdx === -1) priceColIdx = 3;
                    if (imageColIdx === -1) imageColIdx = 4;

                    var brand = safeTrim(cols[brandColIdx] || '');
                    var model = safeTrim(cols[modelColIdx] || '');
                    var storage = safeTrim(cols[storageColIdx] || '');
                    var priceRaw = safeTrim(cols[priceColIdx] || '');
                    var modelLogo = safeTrim(cols[5] || '');

                    if (!brand && !model && !priceRaw) continue;

                    PROGRESS.current++;
                    PROGRESS.status = subFolderName + ": " + brand + " " + model;

                    var doc = app.open(psdFile);

                    var hidePrice = config.hidePrice || false;
                    var hideStorageRam = config.hideStorageRam || false;
                    var isIPhone = model.toLowerCase().indexOf("iphone") !== -1;
                    var shouldHideStorageRam = hideStorageRam || isIPhone;

                    var modelLogoLyr = findLayerByName(doc, "model_logo");
                    if (modelLogoLyr && !isIPhone) {
                        try { modelLogoLyr.remove(); } catch (e) {
                            try { modelLogoLyr.visible = false; } catch (e2) { }
                        }
                    }

                    if (isIPhone) {
                        var brandLay = findLayerByName(doc, mapBrand);
                        if (brandLay) try { brandLay.visible = false; } catch (e) { }

                        var modelLay = findLayerByName(doc, mapModel);
                        if (modelLay) try { modelLay.visible = false; } catch (e) { }

                        var storageLay = findLayerByName(doc, mapStorage);
                        if (storageLay) try { storageLay.visible = false; } catch (e) { }

                        var ramLayers = ["RAM", "Ram", "ram"];
                        for (var R = 0; R < ramLayers.length; R++) {
                            var ramLay = findLayerByName(doc, ramLayers[R]);
                            if (ramLay) try { ramLay.visible = false; } catch (e) { }
                        }

                        var priceLay = findLayerByName(doc, mapPrice);
                        if (priceLay) try { priceLay.visible = !hidePrice; } catch (e) { }

                        var modelLogoLayer = findLayerByName(doc, "model_logo");
                        if (modelLogoLayer) {
                            try { modelLogoLayer.visible = true; } catch (e) { }
                            if (modelLogo) {
                                var modelLogoFile = resolveImageFile(modelLogo, csvFile.parent, config.imgs);
                                if (modelLogoFile && modelLogoFile.exists) {
                                    placeImageNormalized(doc, modelLogoFile, "model_logo");
                                }
                            }
                        }
                    } else {
                        updateText(doc, mapBrand, brand);
                        updateText(doc, mapModel, model);

                        if (shouldHideStorageRam) {
                            var storageLay = findLayerByName(doc, mapStorage);
                            if (storageLay) try { storageLay.visible = false; } catch (e) { }
                            var ramLay = findLayerByName(doc, "RAM");
                            if (ramLay) try { ramLay.visible = false; } catch (e) { }
                            var ramLay2 = findLayerByName(doc, "Ram");
                            if (ramLay2) try { ramLay2.visible = false; } catch (e) { }
                            var ramLay3 = findLayerByName(doc, "ram");
                            if (ramLay3) try { ramLay3.visible = false; } catch (e) { }
                        } else {
                            updateText(doc, mapStorage, storage);
                            var storageLay = findLayerByName(doc, mapStorage);
                            if (storageLay) storageLay.visible = true;
                            var ramLay = findLayerByName(doc, "RAM");
                            if (ramLay) ramLay.visible = true;
                        }

                        var brandLay = findLayerByName(doc, mapBrand);
                        if (brandLay) brandLay.visible = true;
                        var modelLay = findLayerByName(doc, mapModel);
                        if (modelLay) modelLay.visible = true;

                        var priceLay = findLayerByName(doc, mapPrice);
                        if (priceLay) priceLay.visible = !hidePrice;

                        var modelLogoNames = ["Model_Logo", "model_logo", "ModelLogo", "MODEL_LOGO", "Model Logo", "model logo", "MODELLOGO", "Logo", "logo", "LOGO", "iPhone_Logo", "iphone_logo", "iPhone Logo", "Apple_Logo", "apple_logo", "AppleLogo"];
                        for (var ml = 0; ml < modelLogoNames.length; ml++) {
                            var modelLogoLayerHide = findLayerByName(doc, modelLogoNames[ml]);
                            if (modelLogoLayerHide) try { modelLogoLayerHide.visible = false; } catch (e) { }
                        }

                        try {
                            for (var li = 0; li < doc.layers.length; li++) {
                                var layerName = doc.layers[li].name.toLowerCase();
                                if (layerName.indexOf("logo") !== -1 || layerName.indexOf("model_logo") !== -1) {
                                    try { doc.layers[li].visible = false; } catch (e) { }
                                }
                            }
                        } catch (scanErr) { }
                    }

                    var pc = splitPriceCurrency(priceRaw);
                    var priceLayer = findLayerByName(doc, mapPrice);

                    if (priceLayer && !hidePrice) {
                        try {
                            var origBounds = priceLayer.bounds;
                            var originalCenterX = (origBounds[0].as("px") + origBounds[2].as("px")) / 2;
                            updateText(doc, "Price", pc.num);

                            if (pc.cur && priceLayer.kind === LayerKind.TEXT) {
                                var existingCurrency = findLayerByName(doc, "Currency");
                                if (existingCurrency) try { existingCurrency.remove(); } catch (e) { }

                                var actualContent = priceLayer.textItem.contents;
                                priceLayer.textItem.contents = "8";
                                var realBaselineY = priceLayer.bounds[3].as("px");
                                priceLayer.textItem.contents = actualContent;

                                var egpLayer = priceLayer.duplicate();
                                egpLayer.name = "Currency";
                                egpLayer.textItem.contents = pc.cur;
                                if (curColor) egpLayer.textItem.color = curColor;

                                if (scalePct !== 100) {
                                    var oldSize = egpLayer.textItem.size;
                                    var oldVal = (typeof oldSize === "number") ? oldSize : oldSize.value;
                                    egpLayer.textItem.size = new UnitValue(oldVal * (scalePct / 100.0), "pt");
                                }

                                var pBounds = priceLayer.bounds;
                                var priceRightX = pBounds[2].as("px");
                                var cBounds = egpLayer.bounds;
                                var curLeftX = cBounds[0].as("px");
                                var curBottomY = cBounds[3].as("px");

                                var shiftX = priceRightX - curLeftX + 10;
                                var shiftY = realBaselineY - curBottomY;
                                egpLayer.translate(new UnitValue(shiftX, "px"), new UnitValue(shiftY, "px"));

                                var finalEgpBounds = egpLayer.bounds;
                                var currentCenterX = (priceLayer.bounds[0].as("px") + finalEgpBounds[2].as("px")) / 2;
                                var correctionOffset = originalCenterX - currentCenterX;

                                priceLayer.translate(new UnitValue(correctionOffset, "px"), new UnitValue(0, "px"));
                                egpLayer.translate(new UnitValue(correctionOffset, "px"), new UnitValue(0, "px"));
                            }
                        } catch (priceErr) { }
                    } else if (hidePrice) {
                        var currencyLay = findLayerByName(doc, "Currency");
                        if (currencyLay) try { currencyLay.visible = false; } catch (e) { }
                    }

                    // Apply image from dynamic column
                    var imgVal = safeTrim(cols[imageColIdx] || '');
                    if (imgVal) {
                        var imgFile = resolveImageFile(imgVal, csvFile.parent, config.imgs);
                        if (imgFile) placeImageNormalized(doc, imgFile, mapImage);
                    }

                    // Apply ALL dynamic mappings (custom columns/layers)
                    if (config.mappings && config.mappings.length > 0) {
                        for (var dm = 0; dm < config.mappings.length; dm++) {
                            var dMap = config.mappings[dm];
                            var csvColName = dMap.csvColumn;
                            var layerName = dMap.layerName;

                            // Skip the main 5 columns (already handled above)
                            var mainCols = ['brand', 'model', 'storage', 'price', 'image'];
                            var isMainCol = false;
                            for (var mc = 0; mc < mainCols.length; mc++) {
                                if (layerName.toLowerCase() === mainCols[mc]) {
                                    isMainCol = true;
                                    break;
                                }
                            }
                            if (isMainCol) continue;

                            // Find the column value
                            var colIdx = getColumnIndex(headers, csvColName);
                            if (colIdx !== -1) {
                                var colValue = safeTrim(cols[colIdx] || '');
                                if (colValue) {
                                    // Try to update as text layer
                                    updateText(doc, layerName, colValue);
                                }
                            }
                        }
                    }

                    addWatermark(doc);

                    // Inject metadata if enabled
                    if (config.metadata) {
                        var productData = {
                            brand: brand,
                            model: model,
                            storage: storage,
                            price: priceRaw
                        };
                        // Add all CSV columns to productData
                        for (var h = 0; h < headers.length; h++) {
                            var headerName = safeTrim(headers[h]).toLowerCase();
                            productData[headerName] = safeTrim(cols[h] || '');
                        }
                        injectMetadata(doc, config.metadata, productData);
                    }

                    var base = (brand || "item") + "_" + (model || ("idx" + i));
                    var finalName = counter + " " + base;

                    if (config.expPSD) {
                        try { doc.saveAs(new File(outDir.fsName + "/" + finalName + ".psd"), new PhotoshopSaveOptions(), true); } catch (e) { }
                    }
                    if (config.expJPG) {
                        try {
                            var jpgOpt = new JPEGSaveOptions();
                            jpgOpt.quality = jpgQuality;
                            doc.saveAs(new File(outDir.fsName + "/" + finalName + ".jpg"), jpgOpt, true);
                        } catch (e) { }
                    }
                    if (config.expPNG) {
                        try {
                            var pngOpt = new PNGSaveOptions();
                            doc.saveAs(new File(outDir.fsName + "/" + finalName + ".png"), pngOpt, true);
                        } catch (e) { }
                    }
                    if (config.expWEBP) {
                        saveAsWEBP(doc, outDir.fsName + "/" + finalName + ".webp", 80);
                    }

                    try {
                        if (config.expJPG) {
                            var jpgOpt2 = new JPEGSaveOptions();
                            jpgOpt2.quality = jpgQuality;
                            doc.saveAs(new File(combinedSubDir.fsName + "/" + finalName + ".jpg"), jpgOpt2, true);
                        } else if (config.expPNG) {
                            var pngOpt2 = new PNGSaveOptions();
                            doc.saveAs(new File(combinedSubDir.fsName + "/" + finalName + ".png"), pngOpt2, true);
                        } else if (config.expWEBP) {
                            saveAsWEBP(doc, combinedSubDir.fsName + "/" + finalName + ".webp", 80);
                        }
                    } catch (combinedErr) { }

                    doc.close(SaveOptions.DONOTSAVECHANGES);
                    processed++;
                    counter++;

                } catch (imgErr) {
                    try {
                        if (app.documents.length > 0) {
                            app.activeDocument.close(SaveOptions.DONOTSAVECHANGES);
                        }
                    } catch (closeErr) { }
                }
            }
        }

        if (fbPSD && fbPSD.exists) processPSD(fbPSD, "Facebook");
        if (igPSD && igPSD.exists) processPSD(igPSD, "Instagram");
        if (tplPSD && tplPSD.exists) processPSD(tplPSD, "Template");

        PROGRESS.done = true;
        PROGRESS.status = "Completed!";

        savePreferencesJSON(configJSON);

        return JSON.stringify({ count: processed, cancelled: CANCELLED });

    } catch (e) {
        return JSON.stringify({ error: e.message + " (line: " + e.line + ")" });
    }
}

// Catalog Generation
function runCatalogGeneration(configJSON) {
    try {
        var config = eval('(' + configJSON + ')');

        var csvFile = new File(config.csv);
        var saveFolder = new Folder(config.save);
        var catalogPSD = config.catalogTpl ? new File(config.catalogTpl) : null;

        if (!csvFile.exists) return JSON.stringify({ error: "CSV not found" });
        if (!saveFolder.exists) saveFolder.create();
        if (!catalogPSD || !catalogPSD.exists) return JSON.stringify({ catalogCount: 0 });

        var lines = parseCSV(csvFile.fsName);
        if (lines.length < 2) return JSON.stringify({ error: "CSV empty" });

        var products = [];
        var headers = parseCSVLine(lines[0]);
        for (var i = 1; i < lines.length; i++) {
            if (safeTrim(lines[i])) {
                var cols = parseCSVLine(lines[i]);
                var p = {};
                for (var j = 0; j < headers.length; j++) {
                    p[safeTrim(headers[j]).toLowerCase()] = safeTrim(cols[j] || "");
                }
                products.push(p);
            }
        }

        if (products.length === 0) return JSON.stringify({ catalogCount: 0 });

        var catalogFolder = new Folder(saveFolder.fsName + "/Catalog");
        if (!catalogFolder.exists) catalogFolder.create();

        var perPage = config.catalogPerPage || 6;
        var totalPages = Math.ceil(products.length / perPage);
        var jpgQuality = config.jpgQuality || 12;
        var catalogCount = 0;

        for (var pg = 0; pg < totalPages; pg++) {
            if (checkForUserCancel()) break;

            try {
                var doc = app.open(catalogPSD);

                for (var g = 1; g <= perPage; g++) {
                    var grp = findLayerByName(doc, "G" + g);
                    if (grp) grp.visible = false;
                }

                // Helper function to get layer name for a CSV column in catalog
                function getCatalogLayerForColumn(csvColName) {
                    if (!config.mappings) return csvColName;
                    var lowerName = csvColName.toLowerCase();
                    for (var mm = 0; mm < config.mappings.length; mm++) {
                        if (config.mappings[mm].csvColumn &&
                            config.mappings[mm].csvColumn.toLowerCase() === lowerName) {
                            return config.mappings[mm].layerName;
                        }
                    }
                    return csvColName;
                }

                // Helper function to find CSV column name for a layer
                function getCatalogCsvForLayer(layerType) {
                    if (!config.mappings) return layerType;
                    var lowerType = layerType.toLowerCase();
                    for (var mm = 0; mm < config.mappings.length; mm++) {
                        if (config.mappings[mm].layerName &&
                            config.mappings[mm].layerName.toLowerCase() === lowerType) {
                            return config.mappings[mm].csvColumn;
                        }
                    }
                    return layerType;
                }

                var startIdx = pg * perPage;
                for (var slot = 0; slot < perPage; slot++) {
                    var prodIdx = startIdx + slot;
                    if (prodIdx >= products.length) break;

                    var prod = products[prodIdx];
                    var grpName = "G" + (slot + 1);
                    var grp = findLayerByName(doc, grpName);

                    if (grp) {
                        grp.visible = true;

                        // Get CSV column names from mappings
                        var brandCsvCol = getCatalogCsvForLayer('Brand').toLowerCase();
                        var modelCsvCol = getCatalogCsvForLayer('Model').toLowerCase();
                        var storageCsvCol = getCatalogCsvForLayer('Storage').toLowerCase();
                        var priceCsvCol = getCatalogCsvForLayer('Price').toLowerCase();
                        var imageCsvCol = getCatalogCsvForLayer('Image').toLowerCase();

                        // Update text layers using mapped layer names
                        updateTextInGroup(grp, "Brand", prod[brandCsvCol] || "");
                        updateTextInGroup(grp, "Model", prod[modelCsvCol] || "");
                        updateTextInGroup(grp, "Storage", prod[storageCsvCol] || "");
                        updateTextInGroup(grp, "Price", prod[priceCsvCol] || "");

                        // Handle image
                        var imageVal = prod[imageCsvCol] || prod.image || "";
                        if (imageVal) {
                            var img = resolveImageFile(imageVal, csvFile.parent, config.imgs);
                            if (img) placeImageInGroup(doc, grp, img, "Image");
                        }

                        // Apply custom mappings (non-main fields)
                        if (config.mappings && config.mappings.length > 0) {
                            var mainCols = ['brand', 'model', 'storage', 'price', 'image'];
                            for (var dm = 0; dm < config.mappings.length; dm++) {
                                var dMap = config.mappings[dm];
                                var csvColName = dMap.csvColumn;
                                var layerName = dMap.layerName;

                                // Skip main columns
                                var isMainCol = false;
                                for (var mc = 0; mc < mainCols.length; mc++) {
                                    if (layerName.toLowerCase() === mainCols[mc]) {
                                        isMainCol = true;
                                        break;
                                    }
                                }
                                if (isMainCol) continue;

                                // Apply custom field
                                var colValue = prod[csvColName.toLowerCase()] || "";
                                if (colValue) {
                                    updateTextInGroup(grp, layerName, colValue);
                                }
                            }
                        }
                    }
                }

                addWatermark(doc);

                // Inject metadata for catalog page
                if (config.metadata && config.metadata.enabled) {
                    try {
                        var catalogTitle = 'Catalog Page ' + (pg + 1) + ' of ' + totalPages;
                        doc.info.title = catalogTitle;
                        doc.info.description = 'Product catalog page ' + (pg + 1);

                        doc.info.copyrightNotice = '© ListMatic V3';  // Fixed
                        doc.info.credit = 'Generated by ListMatic V3';  // Fixed
                        if (config.metadata.author) {
                            doc.info.author = config.metadata.author;  // User's name
                        }
                    } catch (metaErr) { }
                }

                var fileName = "Catalog_" + zeroPad(pg + 1, 3);

                if (config.expJPG) {
                    var jpgOpt = new JPEGSaveOptions();
                    jpgOpt.quality = jpgQuality;
                    doc.saveAs(new File(catalogFolder.fsName + "/" + fileName + ".jpg"), jpgOpt, true);
                }
                if (config.expPNG) {
                    var pngOpt = new PNGSaveOptions();
                    doc.saveAs(new File(catalogFolder.fsName + "/" + fileName + ".png"), pngOpt, true);
                }

                doc.close(SaveOptions.DONOTSAVECHANGES);
                catalogCount++;
            } catch (e) {
                try { app.activeDocument.close(SaveOptions.DONOTSAVECHANGES); } catch (x) { }
            }
        }

        return JSON.stringify({ catalogCount: catalogCount });

    } catch (e) {
        return JSON.stringify({ error: e.message });
    }
}

function updateTextInGroup(grp, layerName, text) {
    try {
        var n = safeTrim(layerName).toLowerCase();
        for (var i = 0; i < grp.layers.length; i++) {
            var lyr = grp.layers[i];
            if (safeTrim(lyr.name).toLowerCase() === n && lyr.kind === LayerKind.TEXT) {
                lyr.textItem.contents = String(text || "");
                return;
            }
        }
    } catch (e) { }
}

function placeImageInGroup(doc, grp, imgFile, layerName) {
    try {
        var n = safeTrim(layerName).toLowerCase();
        var target = null;

        for (var i = 0; i < grp.layers.length; i++) {
            if (safeTrim(grp.layers[i].name).toLowerCase() === n) {
                target = grp.layers[i];
                break;
            }
        }
        if (!target || !imgFile.exists) return;

        var oldRuler = app.preferences.rulerUnits;
        app.preferences.rulerUnits = Units.PIXELS;

        var b = target.bounds;
        var tW = b[2].as("px") - b[0].as("px");
        var tH = b[3].as("px") - b[1].as("px");
        var tX = (b[0].as("px") + b[2].as("px")) / 2;
        var tY = (b[1].as("px") + b[3].as("px")) / 2;

        try { target.remove(); } catch (e) { }

        var iDoc = app.open(imgFile);
        var iW = iDoc.width.as("px");
        var iH = iDoc.height.as("px");
        iDoc.selection.selectAll();
        iDoc.selection.copy();
        iDoc.close(SaveOptions.DONOTSAVECHANGES);

        app.activeDocument = doc;
        doc.paste();
        var pasted = doc.activeLayer;
        pasted.name = layerName;

        pasted.move(grp, ElementPlacement.INSIDE);

        var scale = Math.min(tW / iW, tH / iH) * 100;
        pasted.resize(scale, scale, AnchorPosition.MIDDLECENTER);

        var pb = pasted.bounds;
        var pX = (pb[0].as("px") + pb[2].as("px")) / 2;
        var pY = (pb[1].as("px") + pb[3].as("px")) / 2;
        pasted.translate(tX - pX, tY - pY);

        app.preferences.rulerUnits = oldRuler;
    } catch (e) { }
}

function zeroPad(num, digits) {
    var s = String(num);
    while (s.length < digits) s = "0" + s;
    return s;
}
